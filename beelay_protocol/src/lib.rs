mod actor;
mod beelay;
mod messages;
pub mod primitives;
mod storage_handling;

// todo: clean up re-exported types so we don't need to reexport so much from Iroh and beelay,
//  also organize these since it is mess right now
pub use crate::actor::NoticeSubscriberClosure;
use crate::primitives::{BeelayTicket, ContactCardWrapper, KeyhiveEntityIdWrapper};
use anyhow::Result;
use beelay_core::contact_card::ContactCard;
pub use beelay_core::doc_status::DocEvent;
pub use beelay_core::{Commit, CommitHash, CommitOrBundle, DocumentId};
use iroh::endpoint::{ApplicationClose, ConnectionError, RecvStream, SendStream, VarInt};
pub use iroh::{Endpoint, protocol::Router};
use iroh::{NodeAddr, endpoint::Connection, protocol::ProtocolHandler};
pub use iroh_base::NodeId;
pub use iroh_base::ticket::{NodeTicket, Ticket};
use n0_future::boxed::BoxFuture;
use primitives::IrohEvent;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::mpsc::Sender;
use tracing::{Instrument, Level, info, span};

/// Application-Layer Protocol Negotiation (ALPN) identifier for the beelay protocol version 1.
pub const ALPN: &[u8] = b"beelay/1";

/// Main protocol handler for the Beelay network protocol implementation over IROH.
/// Manages connections, message handling, and protocol-specific operations.
#[derive(Debug, Clone)]
pub struct IrohBeelayProtocol {
    beelay_actor: Arc<actor::BeelayActor>,
    endpoint: Endpoint,
    listener: Option<Sender<IrohEvent>>,
}

impl IrohBeelayProtocol {
    /// Creates a new instance of IrohBeelayProtocol.
    ///
    /// # Arguments
    /// * `iroh_beelay_id` - The unique identifier for this beelay node and iroh endpoint
    /// * `storage` - Storage implementation for persisting protocol data
    /// * `endpoint` - IROH network endpoint for communication
    ///
    pub async fn new(
        iroh_beelay_id: primitives::IrohBeelayID,
        storage: storage_handling::BeelayStorage,
        endpoint: Endpoint,
    ) -> Self {
        let beelay_actor = actor::BeelayActor::spawn(iroh_beelay_id.into(), storage).await;
        Self {
            beelay_actor: Arc::new(beelay_actor),
            endpoint,
            listener: None,
        }
    }

    /// Returns a reference to the IROH endpoint used by this protocol instance.
    pub fn endpoint(&self) -> &Endpoint {
        &self.endpoint
    }

    pub fn node_id(&self) -> NodeId {
        self.endpoint.node_id()
    }

    /// Contains context to dial a given node including node id, relay info, and addresses
    pub async fn node_addr(&self) -> Result<NodeAddr> {
        self.endpoint.node_addr().await
    }

    /// Serializable ticket providing node dialing context
    pub async fn node_ticket(&self) -> Result<NodeTicket> {
        let node_addr = self.node_addr().await?;
        let ticket = NodeTicket::new(node_addr);
        Ok(ticket)
    }

    /// Beelay representation of a "node/entity"
    /// This is a serializable wrapper
    pub async fn contact_card(&self) -> Result<ContactCardWrapper> {
        let (contact_card, _) = self.beelay_actor().create_contact_card().await.unpack();
        Ok(contact_card?)
    }

    /// represents a combined and serializable ticket for node and contact card
    /// This can be serialized to an ascii string
    pub async fn beelay_ticket(&self) -> Result<BeelayTicket> {
        let contact_card = self.contact_card().await?;
        let node_ticket = self.node_ticket().await?;
        Ok(BeelayTicket::new(node_ticket, contact_card))
    }

    /// Establishes a connection to a remote node using a Beelay ticket and creates a shared document.
    ///
    /// This method performs the complete handshake process for connecting to another Beelay node:
    /// 1. Extracts the node ticket and contact card from the provided Beelay ticket
    /// 2. Creates a new document for message exchange with the remote node as a participant
    /// 3. Establishes a communication stream with the target peer
    /// 4. Dials the remote node and sends initial messages to complete the connection
    ///
    /// The created document can be used for secure communication between the local and remote nodes,
    /// with the remote node having write access through their contact card.
    ///
    /// # Arguments
    /// * `beelay_ticket` - A combined ticket containing both node addressing information and
    ///   contact card for the remote peer. This ticket is typically generated by the remote
    ///   node and shared out-of-band.
    ///
    /// # Returns
    /// * `Ok((DocumentId, NodeTicket))` - A tuple containing:
    ///   - `DocumentId` - The ID of the newly created document for communication
    ///   - `NodeTicket` - The node ticket for the remote peer (for future connections)
    /// * `Err(...)` - An error if document creation, stream setup, or node dialing fails
    ///
    /// # Example
    /// ```rust ignore
    /// // Assuming you have a beelay_ticket from another node
    /// let (doc_id, node_ticket) = protocol.connect_via_beelay_ticket(beelay_ticket).await?;
    ///
    /// // You can now use doc_id for secure communication with the remote node
    /// protocol.add_data_to_document(b"Hello!".to_vec(), doc_id, node_ticket).await?;
    /// ```
    ///
    /// # Errors
    /// This method can fail if:
    /// - Document creation fails due to storage or actor issues
    /// - Stream creation to the target peer fails
    /// - Network connection to the remote node fails
    /// - Message sending during the handshake process fails
    pub async fn connect_via_beelay_ticket(
        &self,
        beelay_ticket: BeelayTicket,
    ) -> Result<(DocumentId, NodeTicket)> {
        let (node_ticket, contact_card) = beelay_ticket.into_components();

        // Create document for exchange of messages, using contact card to facilitate communication in the beelay state machine
        let entity_id = KeyhiveEntityIdWrapper::Individual(contact_card.clone());
        let (doc_result, _) = self
            .beelay_actor()
            .create_doc(vec![], vec![entity_id])
            .await
            .unpack();
        let (doc_id, initial_commit) = doc_result?;
        let target_peer_id = {
            let contact_card_beelay: ContactCard = contact_card.into();
            contact_card_beelay.peer_id()
        };
        let (_, stream_messages) = self
            .beelay_actor()
            .create_stream(target_peer_id)
            .await
            .unpack();

        self.dial_node_and_send_messages(node_ticket.clone().into(), stream_messages)
            .await?;

        Ok((doc_id, node_ticket))
    }

    /// Adds data to an existing Beelay document and synchronizes it with a remote peer.
    ///
    /// This method performs the complete process of adding new data to a shared document:
    /// 1. Retrieves the current status of the document to get the latest commit heads
    /// 2. Creates a new commit containing the provided data, with a hash generated using BLAKE3
    /// 3. Adds the commit to the local document storage
    /// 4. Creates a communication stream to the target peer
    /// 5. Sends the new commit data to the remote peer to maintain synchronization
    ///
    /// The data is stored as a commit in the document's history, allowing for versioning
    /// and conflict resolution. The remote peer will receive and process the new data
    /// through the Beelay protocol's message handling system.
    ///
    /// # Arguments
    /// * `data` - The raw bytes to be added to the document. This can be any serializable
    ///   data that needs to be shared with the remote peer.
    /// * `doc_id` - The identifier of the document to add data to. This should be a document
    ///   that was previously created or that both peers have access to.
    /// * `node_ticket` - The network addressing information for the remote peer that should
    ///   receive the updated document data. This is typically obtained from a previous
    ///   connection or `connect_via_beelay_ticket` call.
    ///
    /// # Returns
    /// * `Ok(())` - Success, indicating the data was added locally and sent to the remote peer
    /// * `Err(...)` - An error if any step in the process fails
    ///
    /// # Example
    /// ```rust ignore
    /// // Add some data to a document and sync with a peer
    /// let message = b"Hello, world!".to_vec();
    /// protocol.add_data_to_document(message, doc_id, node_ticket).await?;
    /// ```
    ///
    /// # Errors
    /// This method can fail if:
    /// - The document ID doesn't exist or isn't accessible
    /// - Commit creation or addition to the document fails
    /// - Stream creation to the target peer fails
    /// - Network connection to the remote peer fails
    /// - Message transmission during synchronization fails
    ///
    /// # Notes
    /// - The data is hashed using BLAKE3 for integrity verification
    /// - The commit is built on top of the current document heads, maintaining the document's history
    /// - The method ensures both local storage and remote synchronization before returning success
    pub async fn add_data_to_document(
        &self,
        data: Vec<u8>,
        doc_id: DocumentId,
        node_ticket: NodeTicket,
    ) -> Result<()> {
        let (doc_status, _) = self.beelay_actor().doc_status(doc_id).await.unpack();
        let local_heads = doc_status.local_heads.unwrap_or_default();
        let data_hash = CommitHash::from(blake3::hash(&data).as_bytes());
        let data_commit = Commit::new(local_heads, data, data_hash);
        let (result, _) = self
            .beelay_actor()
            .add_commits(doc_id, vec![data_commit])
            .await
            .unpack();
        result?;

        let target_peer = node_ticket.node_addr().node_id.public().into();

        let (_, stream_messages) = self
            .beelay_actor()
            .create_stream(target_peer)
            .await
            .unpack();
        
        // todo: generally speaking, we need to implement disconnect on all of these streams, see other todos for additional details.
        self.dial_node_and_send_messages(node_ticket.into(), stream_messages)
            .await?;
        Ok(())
    }

    /// Returns a reference to the BeelayActor that handles protocol logic.
    pub fn beelay_actor(&self) -> &Arc<actor::BeelayActor> {
        &self.beelay_actor
    }

    /// Establishes a connection to a remote node and sends and responds to batches of messages.
    ///
    /// # Arguments
    /// * `node_addr` - Address of the target node
    /// * `messages` - Vector of messages to be sent
    ///
    /// # Returns
    /// Result indicating success or failure of the operation
    #[tracing::instrument(
        skip(self, messages),
        fields(num_messages=messages.len()),
        level = "info"
    )]
    pub async fn dial_node_and_send_messages(
        &self,
        node_addr: NodeAddr,
        messages: Vec<messages::Message>,
    ) -> Result<()> {
        let conn = self.endpoint.connect(node_addr, ALPN).await?;
        let node_id = conn.remote_node_id()?;
        let info = self
            .endpoint
            .remote_info(node_id)
            .expect("Failed to get remote info from what should be a complete connection");
        info!("connection type: {:?}", info.conn_type);

        // send connection info to listener if it exists
        if let Some(listener) = &self.listener {
            let node_addr = NodeAddr::from_parts(
                node_id,
                info.relay_url.and_then(|r| Some(r.relay_url)),
                info.addrs.into_iter().map(|a| a.addr),
            );
            let node_ticket = NodeTicket::new(node_addr);
            let connection_type = info.conn_type;
            let iroh_event = IrohEvent::new(node_ticket, connection_type.into());
            listener.send(iroh_event).await?;
        }

        let (mut send, mut recv) = conn.open_bi().await?;
        self.send_messages(messages, &mut send, &mut recv).await?;
        send.finish()?;
        info!("finished sending messages");
        conn.close(0u32.into(), b"bye!");
        info!("connection closed");
        Ok(())
    }

    // Iterator version of send_messages can be used to investigate
    // stack overflows on the recursive version if needed
    // async fn send_messages(
    //     &self,
    //     messages: Vec<messages::Message>,
    //     send: &mut SendStream,
    //     recv: &mut RecvStream,
    // ) -> Result<()> {
    //     let mut messages: VecDeque<messages::Message> = messages.into();
    //     while !messages.is_empty() {
    //         let msg = messages.pop_front().unwrap();
    //         Self::send_msg(msg, send).await?;
    //         loop {
    //             println!("in loop");
    //             let respond = Self::recv_msg(recv).await?;
    //             if let messages::Message::Done { .. } = respond {
    //                 println!("fround done!!");
    //                 break;
    //             };
    //             let (_, new_messages) = self.beelay_actor.incoming_message(respond).await.unpack();
    //             for m in new_messages.into_iter().rev() {
    //                 messages.push_front(m);
    //             }
    //         }
    //     }
    //     Ok(())
    // }

    /// Sends multiple messages over a stream and handles their responses recursively.
    ///
    /// # Arguments
    /// * `messages` - Vector of messages to send
    /// * `send` - Stream for sending messages
    /// * `recv` - Stream for receiving responses
    ///
    /// # Returns
    /// Result indicating success or failure of sending all messages
    #[tracing::instrument(skip_all, fields(num_messages=messages.len()), level = "info")]
    async fn send_messages(
        &self,
        messages: Vec<messages::Message>,
        send: &mut SendStream,
        recv: &mut RecvStream,
    ) -> Result<()> {
        for msg in messages {
            Self::send_msg(msg, send).await?;
            loop {
                let respond = Self::recv_msg(recv).await?;
                // we use Done to signal that we are done sending messages,
                // there are more efficient ways, but this is straightforward and works for now
                if let messages::Message::Done { .. } = respond {
                    break;
                };
                let (_, messages) = self.beelay_actor.incoming_message(respond).await.unpack();
                Box::pin(self.send_messages(messages, send, recv)).await?;
            }
        }
        Ok(())
    }

    /// Serializes and sends a single message over a stream, encoding the length of the
    /// message alongside the message
    ///
    /// # Arguments
    /// * `msg` - Message to send
    /// * `send` - Stream for sending the message
    ///
    /// # Returns
    /// Result indicating success or failure of sending the message
    async fn send_msg(msg: messages::Message, send: &mut SendStream) -> Result<()> {
        let msg_serializable: messages::SerializableMessage = msg.into();
        let encoded = postcard::to_stdvec(&msg_serializable)?;
        send.write_all(&(encoded.len() as u64).to_le_bytes())
            .await?;
        send.write_all(&encoded).await?;
        Ok(())
    }

    /// Receives and deserializes a message from a stream.
    ///
    /// # Arguments
    /// * `recv` - Stream to receive message from
    ///
    /// # Returns
    /// Result containing the received message or an error
    async fn recv_msg(recv: &mut RecvStream) -> Result<messages::Message> {
        let mut incoming_len = [0u8; 8];
        recv.read_exact(&mut incoming_len).await?;
        let len = u64::from_le_bytes(incoming_len);

        let mut buffer = vec![0u8; len as usize];
        recv.read_exact(&mut buffer).await?;
        let msg: messages::SerializableMessage = postcard::from_bytes(&buffer)?;
        let msg_unserializable: messages::Message = msg.into();
        Ok(msg_unserializable)
    }
}

impl ProtocolHandler for IrohBeelayProtocol {
    /// Handles incoming connections by processing messages and routing responses.
    ///
    /// # Arguments
    /// * `connection` - The incoming connection to handle
    ///
    /// # Returns
    /// BoxFuture containing Result of connection handling
    fn accept(&self, connection: Connection) -> BoxFuture<Result<()>> {
        let beelay_protocol = self.clone();
        let source_peer_id = beelay_protocol.beelay_actor.peer_id();
        let this_node_id = beelay_protocol.endpoint.node_id();

        let node_id = connection
            .remote_node_id()
            .expect("This should be a complete connection");

        let _span = span!(Level::INFO, "incoming_connection", from = %node_id.to_string(), to_this_node = %this_node_id.to_string());
        Box::pin(async move {
            if let Some(listener) = &beelay_protocol.listener {
                let info = beelay_protocol
                    .endpoint
                    .remote_info(node_id)
                    .expect("Failed to get remote info from what should be a complete connection");
                let node_addr = NodeAddr::from_parts(
                    node_id,
                    info.relay_url.and_then(|r| Some(r.relay_url)),
                    info.addrs.into_iter().map(|a| a.addr),
                );
                let node_ticket = NodeTicket::new(node_addr);
                let connection_type = info.conn_type;
                let iroh_event = IrohEvent::new(node_ticket, connection_type.into());
                listener.send(iroh_event).await?
            }
            let (mut send, mut recv) = connection.accept_bi().await?;
            loop {
                // todo: implement proper exit condition here
                // Read the message from the stream.
                match Self::recv_msg(&mut recv).await {
                    Ok(msg) => {
                        info!("received incoming messages");
                        let (_, outgoing_messages) = beelay_protocol
                            .beelay_actor
                            .incoming_message(msg)
                            .await
                            .unpack();
                        let mut handles = Vec::new();
                        for (key, group) in outgoing_messages
                            .into_iter()
                            .fold(HashMap::new(), |mut acc, m| {
                                let target_node_id = m.target_node_id();
                                acc.entry(target_node_id).or_insert_with(Vec::new).push(m);
                                acc
                            })
                            .into_iter()
                        {
                            if key == node_id {
                                info!("sending messages to connected node");
                                for msg in group {
                                    Self::send_msg(msg, &mut send).await?;
                                }
                            } else {
                                info!(name: "sending messages to other node", node_id=%key.to_string());
                                // send out to other nodes, create connections to do so
                                let new_beelay_protocol = beelay_protocol.clone();
                                let task = tokio::spawn(async move {
                                    new_beelay_protocol
                                        .dial_node_and_send_messages(key.into(), group)
                                        .await
                                });
                                handles.push(task);
                            }
                        }
                        info!("finished with responses, send Done message");
                        // Send Done message so sender can terminate loop for this chunk of outgoing
                        Self::send_msg(
                            messages::Message::Done {
                                source: source_peer_id,
                            },
                            &mut send,
                        )
                            .await?;
                        info!("joining {} handles", handles.len());
                        for h in handles {
                            // not ideal for the time being, but this allows us to propagate up errors to the calling function
                            h.await??;
                        }
                    }
                    Err(e) => {
                        // In the case of an error, finish and close the connection, then return the error.
                        let close_result = if let Some(closed_reason) = connection.close_reason() {
                            info!("connection closed with reason: {:?}", closed_reason);
                            match closed_reason {
                                ConnectionError::ApplicationClosed(ApplicationClose { error_code, reason })
                                if error_code == VarInt::from(0u32) && *reason == *b"bye!" => Ok(()),
                                _ => Err(e)
                            }
                        } else { Err(e) };
                        send.finish()?;
                        connection.closed().await;
                        info!("successfully closed connection");
                        return close_result;
                    }
                }
            }
        }.instrument(_span))
    }
}

/// Initializes and starts a new Beelay node and IROH router.
///
/// Creates a new IrohBeelayID, sets up an IROH endpoint with discovery enabled,
/// initializes the protocol handler, and creates a router for handling incoming connections.
///
/// # Returns
/// A tuple containing the protocol router and protocol handler instance
pub async fn start_beelay_node(
    event_listener: NoticeSubscriberClosure,
    listener: Option<Sender<IrohEvent>>,
) -> Result<(iroh::protocol::Router, IrohBeelayProtocol)> {
    let iroh_beelay_id = primitives::IrohBeelayID::generate();
    let endpoint = Endpoint::builder()
        .secret_key(iroh_beelay_id.clone().into())
        .discovery_n0()
        .bind()
        .await?;

    let mut beelay_protocal = IrohBeelayProtocol::new(
        iroh_beelay_id,
        storage_handling::BeelayStorage::new(),
        endpoint.clone(),
    )
    .await;
    // todo: use a builder to construct this
    beelay_protocal.listener = listener;
    beelay_protocal
        .beelay_actor()
        .subscribe_to_notices(event_listener)
        .await;
    let router = iroh::protocol::Router::builder(endpoint)
        .accept(ALPN, beelay_protocal.clone()) // This makes the router handle incoming connections with our ALPN via Echo::accept!
        .spawn();

    Ok((router, beelay_protocal))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::primitives::KeyhiveEntityIdWrapper;
    use beelay_core::keyhive::MemberAccess;
    use beelay_core::{Commit, CommitHash, CommitOrBundle, DocumentId};
    use tokio::sync::mpsc;
    use tokio::sync::mpsc::Receiver;

    fn create_listener_closure() -> (Receiver<(DocumentId, DocEvent)>, NoticeSubscriberClosure) {
        let (tx, rx) = mpsc::channel(100);

        // Note: this is a messy bit of code since types cannot implement impl traits and we need.
        let notice_closure: NoticeSubscriberClosure =
            Box::new(move |doc_id: DocumentId, event: DocEvent| {
                let tx = tx.clone();
                Box::pin(async move {
                    println!("Notice closure called: {}, {:?}", doc_id, event);
                    let send_result = tx.send((doc_id, event)).await;
                    // throw out results for now...
                    match send_result {
                        Ok(_) => {}
                        Err(_) => {}
                    }
                })
            });
        (rx, notice_closure)
    }

    #[tokio::test]
    async fn serialization_connections_test() {
        let (_rx1, notice_closure_1) = create_listener_closure();
        let (_rx2, notice_closure_2) = create_listener_closure();
        let (_node_1, beelay_1) = start_beelay_node(notice_closure_1, None).await.unwrap();
        let ticket = beelay_1.beelay_ticket().await.unwrap();
        let (_node_2, beelay_2) = start_beelay_node(notice_closure_2, None).await.unwrap();
        beelay_2.connect_via_beelay_ticket(ticket).await.unwrap();
    }

    #[tokio::test]
    async fn it_works() {
        // construct a subscriber that prints formatted traces to stdout
        // let subscriber = tracing_subscriber::FmtSubscriber::new();
        // Start configuring a `fmt` subscriber
        let subscriber = tracing_subscriber::fmt()
            // Use a more compact, abbreviated log format
            .compact()
            // Display source code file paths
            .with_file(true)
            // Display source code line numbers
            .with_line_number(true)
            // Display the thread ID an event was recorded on
            .with_thread_ids(true)
            // Don't display the event's target (module path)
            .with_target(false)
            // Build the subscriber
            // .with_max_level(Level::TRACE)
            .finish();
        // use that subscriber to process traces emitted after this point
        tracing::subscriber::set_global_default(subscriber).unwrap();
        let (_rx1, notice_closure_1) = create_listener_closure();
        let (_rx2, notice_closure_2) = create_listener_closure();
        let (node_1, beelay_1) = start_beelay_node(notice_closure_1, None).await.unwrap();
        let (node_2, beelay_2) = start_beelay_node(notice_closure_2, None).await.unwrap();

        let test_content = Vec::new();
        let (doc_result, _) = beelay_1
            .beelay_actor()
            .create_doc(test_content, vec![])
            .await
            .unpack();
        let (document_id, initial_commit) = doc_result.expect("Failed to create document");

        // 3. Create a contact card for the second actor
        let (contact_card_result, _) = beelay_2.beelay_actor().create_contact_card().await.unpack();
        let contact_card = contact_card_result.expect("Failed to create contact card");

        // 4. Convert the contact card into a KeyhiveEntityIdWrapper of the Individual type
        let entity_id = KeyhiveEntityIdWrapper::Individual(contact_card);

        // 5. Add the second actor as a member to the document created on the first actor
        let (_, add_member_messages) = beelay_1
            .beelay_actor()
            .add_member_to_doc(document_id, entity_id, MemberAccess::Write)
            .await
            .unpack();

        // 6. Create a stream from the first actor to the second actor
        let target_peer_id = beelay_2.beelay_actor().peer_id();
        let (stream_id, stream_messages) = beelay_1
            .beelay_actor()
            .create_stream(target_peer_id)
            .await
            .unpack();

        // 7. Assert that there are outgoing messages from the stream creation
        assert!(
            !stream_messages.is_empty(),
            "Expected outgoing messages from stream creation"
        );

        let node_addr_2 = node_2.endpoint().node_addr().await.unwrap();
        beelay_1
            .dial_node_and_send_messages(node_addr_2, stream_messages)
            .await
            .unwrap();

        let (status, _) = beelay_2
            .beelay_actor()
            .doc_status(document_id)
            .await
            .unpack();

        assert_eq!(
            status,
            beelay_core::doc_status::DocStatus {
                local_heads: Some(vec![initial_commit.hash()])
            }
        );
        // FIXME: Initial commit is not sent to other nodes!!  this is a problem according
        //  to the beelay tests in the keyhive repo too.

        let actual_content = vec![1, 2, 3];
        let good_commit = Commit::new(
            vec![initial_commit.hash()],
            actual_content.clone(),
            CommitHash::from([1; 32]),
        );

        let (_, new_messages) = beelay_1
            .beelay_actor()
            .add_commits(document_id, vec![good_commit.clone()])
            .await
            .unpack();

        assert!(!new_messages.is_empty());

        let node_addr_2 = node_2.endpoint().node_addr().await.unwrap();
        beelay_1
            .dial_node_and_send_messages(node_addr_2, new_messages)
            .await
            .unwrap();

        let (commits_1, _) = beelay_1.beelay_actor().load_doc(document_id).await.unpack();

        let commit_filter = |commits: Option<Vec<CommitOrBundle>>| {
            commits
                .unwrap()
                .into_iter()
                .filter_map(|com| match com {
                    CommitOrBundle::Commit(c) => {
                        if c.hash() == good_commit.hash() {
                            Some(c)
                        } else {
                            None
                        }
                    }
                    _ => None,
                })
                .collect::<Vec<_>>()
        };

        let commits_1 = commit_filter(commits_1);

        let (commits_2, _) = beelay_2.beelay_actor().load_doc(document_id).await.unpack();
        let commits_2 = commit_filter(commits_2);

        assert_eq!(commits_1, commits_2);

        // This makes sure the endpoint in the router is closed properly and connections close gracefully
        node_1.shutdown().await.unwrap();
        node_2.shutdown().await.unwrap();
    }
}
